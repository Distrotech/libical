#!/usr/bin/perl
# -*- Mode: perl -*-
#======================================================================
# FILE: Libical.pm
# CREATOR: eric 
#
# DESCRIPTION:
#   
#
#  $Id: Libical.pm,v 1.1 2001-01-28 16:37:44 ebusboom Exp $
#  $Locker:  $
#
# (C) COPYRIGHT 2000, Eric Busboom, http://www.softwarestudio.org
#
# This package is free software and is provided "as is" without express
# or implied warranty.  It may be used, redistributed and/or modified
# under the same terms as perl itself. ( Either the Artistic License or the
# GPL. ) 
#
# The Original Code is Parameter.pm. The Initial Developer of the Original
# Code is Eric Busboom
#
#======================================================================

# This part of this file was automatically generated by SWIG
package Net::ICal::Libical;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package Net::ICal::Libical;
bootstrap Net::ICal::Libical;
var_Net__ICal__Libical_init();
@EXPORT = qw( );

$VERSION = "0.01";

1;

package Net::ICal::Libical;

sub parse_string {
  my $comp_str = shift;
 
  my $c = Net::ICal::Libical::icalparser_parse_string($comp_str); 
  my $out;

  die "Failed to parse component" if !$c;

  my $r = Net::ICal::Libical::icalrestriction_check($c);

  my @props = (METHOD,ORGANIZER,DTSTART,SUMMARY);

  foreach $pn (@props){

    my $p = Net::ICal::Libical::icalperl_get_property($c,0,$pn);

    my $v = Net::ICal::Libical::icalperl_get_property_val($p);

    print "$pn $v\n";
  }

  Net::ICal::Libical::icalcomponent_free($c);

}


sub validate_component {
  my $comp_str = shift;
 
  my $c = Net::ICal::Libical::icalparser_parse_string($comp_str); 
  my $out;

  die "Failed to parse component" if !$c;

  my $r = Net::ICal::Libical::icalrestriction_check($c);
  
  $out = Net::ICal::Libical::icalcomponent_as_ical_string($c);

  Net::ICal::Libical::icalcomponent_free($c);

  return $out;

}


sub generate_occurrences {
  my $rule = shift;
  my $start = shift;
  my $count = shift;

  my @out;

  my $array = Net::ICal::Libical::new_array(25);

  Net::ICal::Libical::icalrecur_expand_recurrence($rule,$start,
						$count,$array);
		   
  for($i = 0; $i<$count; $i++){
    my $t = Net::ICal::Libical::access_array($array,$i);
    if($t != 0) {
      push(@out,$t);
    }

  }

  Net::ICal::Libical::free_array($array);

  return @out;
}


1;
